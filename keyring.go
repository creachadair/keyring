// Package keyring implements self-contained encrypted storage for a versioned collection of
// versioned byte strings, typically cryptographic keys or access tokens.
//
// # Outline
//
// To create a new keyring, call [New]. You must provide an access key and the
// first key version to initialize the ring:
//
//	r, err := keyring.New(keyring.Config{
//	   AccessKey:  accessKey,
//	   InitialKey: []byte("hunter2"},
//	})
//
// The access key must be exactly [AccessKeyLen] bytes. The keys stored in the
// keyring may be of any length, but must not be empty.
//
// Each key version in the keyring is identified by a unique [ID]. At any time,
// one version is identified as the "active" version. Call [Ring.Active] to
// obtain the active ID.
//
//	active := r.Active()
//
// To add a new key version, use [Ring.Add] or [Ring.AddRandom]:
//
//	id := r.Add([]byte("hunter2 hunter2"))
//
// Adding a new key does not change the active version. Use [Ring.Activate] to
// change the current active version:
//
//	r.Activate(id)
//
// To retrieve a key version, use [Ring.Get]:
//
//	key := r.Get(id)
//
// This returns a copy of the key at that version. If you want to control
// allocation, you may instead use [Ring.Append]:
//
//	var buf []byte
//	buf = r.Append(id, buf)
//
// Both of these methods will panic if the provided ID is unknown.  As a
// special case, an id of 0 (also known as [ActiveKey]) will address the active
// key version. Otherwise, use [Ring.Has] to test whether a given version is
// present:
//
//	if r.Has(id) {
//	   log.Printf("Key id %v is present", id)
//	}
//
// # Storage
//
// To write a keyring to persistent storage, use [Ring.WriteTo]:
//
//	f, err := os.Create("key.ring")
//	// ...
//	nw, err := r.WriteTo(f)
//
// To read a keyring from persistent storage, use [Read]:
//
//	f, err := os.Open("key.ring")
//	// ...
//	r, err := keyring.Read(f, accessKeyFunc)
//
// The [AccessKeyFunc] returns the access key used to decrypt the stored ring.
//
// The binary encoding format of a [Ring] is defined in the [packet] package.
//
// # Access Keys
//
// An access key is a 32-byte symmetric encryption key. It must be provided to
// create a new keyring, or to read a saved keyring. In order to allow access
// keys generated by a key-derivation function, a [Ring] may optionally store
// an access-key generation salt provided by the user.
//
// For example, if accessKey is generated by combining a root key with salt and
// other context, you may provide that context when constructing the ring:
//
//	r, err := keyring.New(keyring.Config{
//	   InitialKey:    []byte("hunter2"),
//	   AccessKey:     accessKey,  // derived from baseKey + keySalt
//	   AccessKeySalt: keySalt,
//	})
//
// The keyring will persist keySalt in storage, and will pass it to the
// [AccessKeyFunc] provided when reading it:
//
//	r, err := keyring.Read(f, func(keySalt []byte) []byte {
//	    return someKDF(baseKey, keySalt, ...)
//	})
//
// If you do not use a key-derivation function, use [StaticKey].
// The [PassphraseKey] and [AccessKeyFromPassphrase] helpers may also be useful
// if you want to derive an access key from a user-provided low-entropy
// passphrase.
package keyring

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/creachadair/keyring/internal/cipher"
	"github.com/creachadair/keyring/internal/packet"
)

// An ID identifies a particular version of a key stored in a [Ring].
// A valid ID value is positive.
type ID int

// ActiveKey is a special key ID value used to indicate the current active key
// ID in a ring. See [Ring.Append] and [Ring.Get].
const ActiveKey ID = 0

// A Ring is a versioned collection of byte strings, typically cryptographic
// keys or access tokens. The contents of a ring can be serialized in binary
// format for persistent storage, and are symmetrically encrypted under a
// randomly-generated data storage key.
//
// In storage, the data storage key is itself symmetrically encrypted with a
// user-provided access key and stored alongside the encrypted keyring
// contents.  When a keyring is read, the access key is used to recover the
// data storage key, which can then be used to decrypt and re-encrypt the
// contents of the keyring without further need of the access key.
type Ring struct {
	formatVersion byte
	reserved      [2]byte // reserved format data
	accessKeySalt []byte  // access key generation salt (optional)
	dkEncrypted   []byte  // data storage key (for writing output)
	dkPlaintext   []byte  // plaintext data storage key (in-memory only)

	keys      []packet.KeyInfo // key versions
	activeKey int              // index of active key
	maxID     ID               // maximum in-use key index
}

// New constructs a new [Ring] from c. At minimum, a non-empty initial key and
// an access key must be provided. It reports an error if any required options
// are unset or invalid, or if a data encryption key could not be generated.
func New(c Config) (*Ring, error) {
	switch {
	case len(c.InitialKey) == 0:
		return nil, errors.New("keyring: initial key is empty")
	case len(c.AccessKey) != AccessKeyLen:
		return nil, fmt.Errorf("keyring: access key is %d bytes, want %d", len(c.AccessKey), AccessKeyLen)
	}
	pkey, ekey, err := cipher.GenerateAndEncryptKey(c.AccessKey, AccessKeyLen)
	if err != nil {
		return nil, err
	}
	return addCleanup(&Ring{
		formatVersion: 1,
		accessKeySalt: bytes.Clone(c.AccessKeySalt),
		dkEncrypted:   ekey,
		dkPlaintext:   pkey,
		keys:          []packet.KeyInfo{{ID: 1, Key: bytes.Clone(c.InitialKey)}},
		maxID:         1,
	}), nil
}

// Read parses, and decrypts the binary representation of a [Ring] from r.
// It fully consumes the contents of r.
//
// The accessKey function is called to obtain the encryption key for the ring itself.
// If the ring has a key generation salt, it is passed to the accessKey function;
// otherwise the salt argument is nil.
func Read(r io.Reader, accessKey AccessKeyFunc) (*Ring, error) {
	data, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}
	rk, err := packet.ParseKeyring(data)
	if err != nil {
		return nil, fmt.Errorf("parse keyring: %w", err)
	}
	if rk.Version != 1 {
		return nil, fmt.Errorf("keyring: unknown format version %d", rk.Version)
	}
	if rk.Reserved != ([2]byte{}) {
		return nil, errors.New("keyring: reserved data are set")
	}

	// Check that the packets we found are sensible:
	// - Exactly one data key
	// - At most one access key salt
	// - No unencrypted keyring entries
	// - Otherwise only bundles
	var encDK, salt packet.Packet
	var bundles []packet.Packet
	for _, p := range rk.Packets {
		switch p.Type {
		case packet.DataKeyType:
			if encDK.IsValid() {
				return nil, errors.New("keyring: multiple data keys found")
			}
			encDK = p
		case packet.AccessKeySaltType:
			if salt.IsValid() {
				return nil, errors.New("keyring; multiple access key salts")
			}
			salt = p
		case packet.KeyringEntryType:
			return nil, errors.New("keyring: unencrypted keyring entry found")
		case packet.BundleType:
			bundles = append(bundles, p)
		default:
			return nil, fmt.Errorf("keyring: invalid packet %v", p.Type)
		}
	}
	if !encDK.IsValid() {
		return nil, errors.New("keyring: no data key found")
	}

	akey := accessKey(salt.Data)
	if len(akey) != AccessKeyLen {
		return nil, fmt.Errorf("access key is %d bytes, want %d", len(akey), AccessKeyLen)
	}

	// Failure to encrypt the data key most likely indicates the wrong access
	// key was provided, so report an error on that basis.
	plainDK, err := encDK.Decrypt(akey)
	if err != nil {
		return nil, fmt.Errorf("invalid access key: %w", err)
	}

	// Now verify that we can decrypt all the bundles with the data key, and
	// that they contain only keyring entries and (exactly) one active key.
	var active packet.Packet
	var entries []packet.Packet
	for i, b := range bundles {
		bdata, err := b.Decrypt(plainDK)
		if err != nil {
			return nil, fmt.Errorf("decrypt bundle %d: %w", i+1, err)
		}
		pkts, err := packet.ParsePackets(bdata, 0)
		if err != nil {
			return nil, fmt.Errorf("parse bundle %d: %w", i+1, err)
		}
		for j, p := range pkts {
			// An active key packet is valid, but only once.
			// Everything else must be a keyring entry.
			if p.Type == packet.ActiveKeyType {
				if active.IsValid() {
					return nil, fmt.Errorf("bundle %d item %d: duplicate active key", i+1, j+1)
				}
				active = p
				continue
			} else if p.Type != packet.KeyringEntryType {
				return nil, fmt.Errorf("bundle %d item %d: invalid packet %v", i+1, j+1, p.Type)
			}
			entries = append(entries, p)
		}
	}

	// There must have been at least one key, and an active key marker.
	if len(entries) == 0 {
		return nil, errors.New("keyring: no keys found")
	} else if !active.IsValid() {
		return nil, errors.New("keyring: no active key ID found")
	}

	activeKeyID, err := packet.ParseActiveKey(active.Data)
	if err != nil {
		return nil, fmt.Errorf("active key ID: %w", err)
	}

	// Parse the key packets, sort them by ID, make sure there are no duplicate
	// IDs, and find the index of the active key.
	//
	// This package will never generate duplicates and will always write the
	// output in order, but we want to be defensive here.
	var keys []packet.KeyInfo
	var maxID int
	for i, e := range entries {
		ki, err := packet.ParseKeyInfo(e.Data)
		if err != nil {
			return nil, fmt.Errorf("keyring entry %d: %w", i+1, err)
		}
		keys = append(keys, ki)
		if ki.ID > maxID {
			maxID = ki.ID
		}
	}
	packet.SortKeysByID(keys)
	for i := range len(keys) - 1 {
		if keys[i].ID == keys[i+1].ID {
			return nil, fmt.Errorf("keyring: duplicate ID %v for key %d", keys[i].ID, i+1)
		}
	}
	i := packet.FindKey(keys, activeKeyID)
	if i < 0 {
		return nil, fmt.Errorf("keyring: active key ID %v not found", activeKeyID)
	}
	return addCleanup(&Ring{
		formatVersion: rk.Version,
		reserved:      rk.Reserved,
		accessKeySalt: salt.Data,
		dkEncrypted:   encDK.Data,
		dkPlaintext:   plainDK,
		keys:          keys,
		activeKey:     i,
		maxID:         ID(maxID),
	}), nil
}

// Len reports the number of keys in r.
func (r *Ring) Len() int { return len(r.keys) }

// Active reports the current active key ID in r.
func (r *Ring) Active() ID { return ID(r.keys[r.activeKey].ID) }

// Has reports whether r contains a key with the given ID.
func (r *Ring) Has(id ID) bool { return packet.FindKey(r.keys, int(id)) >= 0 }

// Activate activates the specified key ID in r. It has no effect if the given
// key ID is already active. It panics if id does not exist in r.
func (r *Ring) Activate(id ID) {
	pos := packet.FindKey(r.keys, int(id))
	if pos < 0 {
		panic(fmt.Sprintf("keyring: no such key: %v", id))
	}
	r.activeKey = pos
}

// AddRandom adds a new randomly-generated n-byte key to r, and returns its ID.
// It is shorthand for calling [Ring.Add] with a randomly-generated key.
// It will panic if n â‰¤ 0.
func (r *Ring) AddRandom(n int) ID {
	if n <= 0 {
		panic(fmt.Sprintf("keyring: key length %d is not positive", n))
	}
	return r.addBytes(cipher.GenerateKey(n))
}

// Add adds the specified non-empty key to r and returns its new ID.
// If r is empty, the The added key is not marked active; use [Ring.Activate]
// to make it active. It panics if len(key) == 0.
func (r *Ring) Add(key []byte) ID {
	if len(key) == 0 {
		panic("keyring: empty key")
	}
	return r.addBytes(bytes.Clone(key))
}

// Append appends the contents of the specified key to buf, and returns the
// resulting slice. It panics if id does not exist in r.
// As a special case, if id == 0 it will append the current active key.
func (r *Ring) Append(id ID, buf []byte) []byte {
	if id == 0 {
		id = ID(r.keys[r.activeKey].ID)
	}
	pos := packet.FindKey(r.keys, int(id))
	if pos < 0 {
		panic(fmt.Sprintf("keyring: no such key: %v", id))
	}
	return append(buf, r.keys[pos].Key...)
}

// Get returns a copy of the specified key. It will panic if id does not exist
// in r.  As a special case, if id == 0 it will fetch the current active key.
func (r *Ring) Get(id ID) []byte {
	if id == 0 {
		id = ID(r.keys[r.activeKey].ID)
	}
	pos := packet.FindKey(r.keys, int(id))
	if pos < 0 {
		panic(fmt.Sprintf("keyring: no such key: %v", id))
	}
	return bytes.Clone(r.keys[pos].Key)
}

// Rekey generates a new data storage key for r, and changes the access key to
// the provided value. If an error occurs, the current state of r is unchanged.
// The accessKey must be exactly [AccessKeyLen] bytes; the salt may be empty or nil.
func (r *Ring) Rekey(accessKey, accessKeySalt []byte) error {
	if len(accessKey) != AccessKeyLen {
		return fmt.Errorf("keyring: access key is %d bytes, want %d", len(accessKey), AccessKeyLen)
	}
	pkey, ekey, err := cipher.GenerateAndEncryptKey(accessKey, AccessKeyLen)
	if err != nil {
		return err
	}
	r.dkPlaintext = pkey
	r.dkEncrypted = ekey
	r.accessKeySalt = bytes.Clone(accessKeySalt)
	return nil
}

// WriteTo encrypts and encodes r in binary format and writes the result to w.
// It satisfies the [io.WriterTo] interface.
func (r *Ring) WriteTo(w io.Writer) (int64, error) {
	var root packet.Buffer
	root.WriteHeader(r.formatVersion, r.reserved)
	root.AddPacket(packet.DataKeyType, r.dkEncrypted)
	if len(r.accessKeySalt) != 0 {
		root.AddPacket(packet.AccessKeySaltType, r.accessKeySalt)
	}

	// The keys and active key ID go into an encrypted bundle.
	var kb packet.Buffer
	kb.AddActiveKey(r.keys[r.activeKey].ID)
	for _, ki := range r.keys {
		kb.AddKeyringEntry(ki)
	}
	defer clear(kb.Bytes())

	_, data, err := cipher.EncryptWithKey(r.dkPlaintext, kb.Bytes(), nil)
	if err != nil {
		return 0, fmt.Errorf("encrypt ring: %w", err)
	}

	root.AddPacket(packet.BundleType, data)
	defer clear(root.Bytes())
	return root.WriteTo(w)
}

// Config carries the settings for a [Ring].
type Config struct {
	// The initial active key for the ring. This field must be non-empty.
	InitialKey []byte

	// The secret key to decrypt the data encryption key.
	// This must be exactly [AccessKeyLen] bytes.
	AccessKey []byte

	// An optional key-generation salt for the access key. If provided, this
	// value will be passed to the accessKey callback of [Read] when reading the
	// keyring from storage. This may be empty or nil.
	AccessKeySalt []byte
}
